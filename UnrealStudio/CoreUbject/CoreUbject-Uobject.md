# (原、整) Unreal源码 CoreUbject- Uobject

2018年10月18日

20:44

@author:白袍小道

随缘那啥

 

这里还是属于UE的源码解析（大言不惭，应该叫学习嘿嘿）目录。

## 说明

1、按引擎分层，这里应该属于Core后，引擎支撑中上层（还没到Core）

（额外说下分析UE的症状：

核心层[Core]是颤抖+苦笑

数据模型层[CoreUObject]头皮发麻+谄笑

引擎层1[Rneder,RHI,Physical,Anim。几个] 是头晕+呆笑

引擎层2[Render,Phy.Ani算法实现], 是难受+傻笑

引擎游戏性[Gameplay部分，接入蓝图虚拟机哪些]  绕绕绕+冲动

引擎的编辑器，工具，脚本【蓝图】材质特效，的实现是烦躁+开心

游戏部分，翻白+汗流浃背+开心。

）

2、因为GoreUObject起到承上启下的作用，灰常重要。所以得分很多目测30小部分来悄悄。而且这部分分析和总结的大神和经典文章也可以看到许多。这里小道主要按源码，图，文章，分析整理总结一二而得。

3、什么？如何做？ 到为什么？然后反复几次，这是后面的写法。

 

## 关键词

Unreal：模版类型，类型系统，结构，UHT，反射，序列化，Meta(元数据），GC，

默认Object，属性集、引擎的内存管理（不是底层：页，双端，内存查找那些那啥），编辑器调整数据（EditorVisiable)，

平衡和权衡

 

## 前言

​        首先先理解一些名称，有句话叫做 一个事物可以用一个名称+动词 去表述的话，就很舒服了，但理解和深入部分可以不断去整。

​        为何要看看？因为这些经常用到，能帮助我们偷懒和降低复杂度。

 

| 反射           | 程序在运行时进行自检的一种能力，是一种属性系统的控制。（自检：能**检查**出自己的**组成或属性**部分，但不能**提前**知道自己是啥）如：能列举出所有属性（属性本身也是个抽象封装），通过这封装知道属性是啥或者属于啥。   for (TFieldIterator<UProperty>   PropIt(GetClass()); PropIt; ++PropIt)   {   UProperty* Property = *PropIt;   }       来自 <[*http://www.cnblogs.com/ghl_carmack/p/5698438.html*](http://www.cnblogs.com/ghl_carmack/p/5698438.html)> |
| -------------- | ------------------------------------------------------------ |
| 注解和标记     | 一种代码级别的**说明信息标识**。UE这里就是一个宏，用来封装了由Unreal头文件工具解析的元数据，当然在c++编译器编译包含它们的代码时被忽略（因为最后用来编译的C++部分，是生成的啊）   如   UPROPERTY(EditAnywhere,   BlueprintReadOnly, Category = Material, meta = (DisplayName = "Subsurface   Profile"))   class   USubsurfaceProfile* SubsurfaceProfile;        Local:    CoreUObject/Public/Uobject/ObjectMacros,UObjectMarks, |
| UBT和UHT:      | **UBT**属性可以通过扫描头文件，记录任何至少有一个反射类型的头文件的模块，并且生成包含反射数据的C++代码（XXXmodule.generated.cpp中去）。如果任意一个比较上一次编译结果发生了变化，那么它会利用**UHT**更新反射数据。   （用**生成的**C++代码来存储反射数据的一个最大好处就是，它可以保证跟二进制做到同步。你永远也不会加载陈旧或者过时的反射数据，因为它是跟引擎的其它代码同时编译的，并且它会在程序启动的时候使用C++表达式来计算成员偏移等，而不是通过针对特定平台/编译器/优化的组合中进行逆向工程。UHT避免了所属关系导致的先后生成的问题，因为**UHT作为一个单独的不使用任何生成头文件的程序来构建**）       来自 <[*http://www.cnblogs.com/ghl_carmack/p/5698438.html*](http://www.cnblogs.com/ghl_carmack/p/5698438.html)> |
| 序列化         | 一个把对象的变量（应该叫属性），存储（传输也是一个存储）的过程。反之就反序列化。       Local:    **Runtime/CoreUObject/Serialization/** |
| 默认Object     | **可以通过类获得默认对象，具体略**                           |
| 属性集         | **如C#的Assembly,命名空间等（一些抽象封装）：如**this.GetType().Assembly;   通过反射可以获得Type然后巴拉巴拉。   （C#元： class   MemberInfo : ICustomAttributeProvider）原生C++莫有，那自己整整？。 |
| 编辑器编辑数据 | **能反射或列举就可以那啥了，**                               |
| GC             | **引用计数，标记待清理，Link方式（Root配 Node这种），目的就是能适当的自动回收无用对象和避免回收了有用对象。** |
| 模版类型       | **略，模版、元什么的 小道不敢说，这个部分资料和代码也很多，各位看官那啥。（在CoreTemple 中倒是可以肤浅说丢丢）** |

 

 

听说UE3后期orUE4 ：一为了跨平台和稳得住，二来为了迭代技术，三是历史原因（这什么产品和技术或者理论感觉都是有历史的部分因数的）

【这里扯淡，勿当真】

好多要整啊，那么。。。

 

1、但如果每个都单独整下就会很累，所以是不是有个**不大不小**，能恰当复合了部分组成一个模式让我们更简单的使用，但同时不会让这个太过庞大影响性能和掌控（单一的**粒度**）。

2、能不能有个辅助的工具，帮助我们更简单快速的黑箱制造过程。（**工具**）

 

针对以上会得到几个想法前（憋住），我们先看UE的CoreUObject中UObject及其相关。

（以下尽量图为主，一来能看官可以对着源码或者调试时候那啥，二来一图胜许多节约能量）

 

（未完待续。。。。）

What：

![](./CoreUbject- Uobject.assets/clip_image002.jpg)

从上图基本是

1、能看到UOBJECT作为一个基础，一来包含了常用的Object需要的行为及其为此提供的必要数据（序列化，反射，类型，回收等）

2、抽出了许多UXXX（定义），将属性抽象。

3、Unreal类型的含义：

*派生自* **Object** *的类前缀为* **U***，*

**Enums** *的前缀为* **E**

**Template** *类的前缀为* **T**

*其余类的前缀均为 字母* **F** 

 

HOW：

1、反射如何做到的？

 

2、序列化如何做到的？

 

3、回收和分配如何做到的？

 

4、查询和管理？

 

 

Why：

 

What：

 

How：

 

Why：

 

## 总结

 

 
