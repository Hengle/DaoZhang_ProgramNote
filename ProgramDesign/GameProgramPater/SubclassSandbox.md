## 子类沙箱模式 Subclass Sandbox

用一系列由基类提供的操作定义子类中的行为。

### 

### 要点

子类沙箱模式：基类定义抽象的沙箱方法和几个提供操作的实现方法，将他们设为protected，表明它们只为子类所使用。每个推导出的沙箱子类用提供的操作实现了沙箱方法。

### 

### 使用场合

子类沙箱模式是潜伏在编程日常中简单常用的模式，哪怕是在游戏之外的地方。 如果有一个非虚的protected方法，你可能早已在用类似的技术了。

沙箱方法在以下情况适用：

- 你有一个能推导很多子类的基类。
- 基类可以提供子类需要的所有操作。
- 在子类中有行为重复，你想要更容易的在它们间分享代码。
- 你想要最小化子类和程序的其他部分的耦合。

### 

### 引申与参考

- 当你使用上文中介绍到的更新模式时，你的更新函数通常也是沙箱方法。
- 这个模式与GOF模板方法正好相反。两种模式中，都使用了一系列受限操作实现方法。使用子类沙箱时，方法在推导类中，受限操作在基类中。使用模板方法时，基类有方法，而受限操作在推导类中。
- 你也可以认为这个模式是GOF外观模式的变形。外观模式将一系列不同系统藏在简化的API后。使用子类沙箱，基类起到了在子类前隐藏整个游戏引擎的作用。
- 子类沙箱模式的Unity版本实现：<https://github.com/QianMo/Unity-Design-Pattern/tree/master/Assets/Game%20Programming%20Patterns/SubclassSandbox%20Pattern>
- 本节内容相关的英文原文：<http://gameprogrammingpatterns.com/subclass-sandbox.html>
- 本节内容相关的中文翻译：<http://gpp.tkchu.me/subclass-sandbox.html>
