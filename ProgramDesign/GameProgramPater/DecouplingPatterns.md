# 解耦型模式 Decoupling Patterns

这一部分的三种模式，专注于解耦：

- 组件模式将一个实体拆成多个，解耦不同的领域。
- 事件队列解耦了两个互相通信的事物，稳定而且实时。
- 服务定位器让代码使用服务而无需绑定到提供服务的代码上。

## 

## 13. 组件模式 Component

允许单一的实体跨越多个领域，无需这些领域彼此耦合。

### 

### 要点

- 组件模式：在单一实体跨越了多个领域时，为了保持领域之间相互解耦，可以将每部分代码放入各自的组件类中，将实体简化为组件的容器。
- Unity引擎在设计中频繁使用了这种设计方法，从而让其易于使用。

### 

### 使用场合

组件通常在定义游戏实体的核心部分中使用，当然，它们在其他地方也适用。这个模式在如下情况下可以很好的适用：

- 有一个涉及了多个领域的类，而你想保持这些领域互相隔离。
- 一个类正在变大而且越来越难以使用。
- 想要能定义一系列分享不同能力的类，但是使用接口不足以得到足够的重用部分。

### 

### 引申与参考

- Unity核心架构中GameObject类完全根据此模式来进行设计。
- 这种模式与GOF设计模式中的策略模式类似。两种模式都是将对象的行为取出，委派到一个单独的从属对象中。两者的不同点在于：
- 策略模式中分离出的策略对象通常是无状态的——它封装的是算法，而不是数据。策略模式定义了对象的行为，而不是该对象是什么。
- 而组件模式就更加复杂。组件经常保存了对象的状态，这有助于确定其真正的身份。但是，其界限往往很模糊。有些情况下组件也许根本没有任何状态。在这种情况下，你可以在不同的容器对象中使用相同的组件实例。这样看来，它的行为确实更像一种策略。
- 本节内容相关的英文原文：<http://gameprogrammingpatterns.com/component.html>
- 本节内容相关的中文翻译：<http://gpp.tkchu.me/component.html>
