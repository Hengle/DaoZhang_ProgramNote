## 对象池模式 Object Pool

放弃单独地分配和释放对象，从固定的池中重用对象，以提高性能和内存使用率

### 

### 要点

- 对象池模式：定义一个包含了一组可重用对象的对象池。其中每个可重用对象都支持查询“使用中”状态，说明它是不是“正在使用”。对象池被初始化时，就创建了整个对象集合（通常使用一次连续的分配），然后初始化所有对象到“不在使用中”状态。
- 当我们需要新对象时，就从对象池中获取。从对象池取到一个可用对象，初始化为“使用中”然后返回给我们。当不再需要某对象时，将其设置回“不在使用中”状态。通过这种方式，便可以轻易地创建和销毁对象，而不必每次都分配内存或其他资源。

### 

### 使用场合

- 这个模式广泛使用在可见事物上，比如游戏物体和特效。但是它也可在不那么视觉化的数据结构上使用，比如正在播放的声音。
- 满足以下情况可以使用对象池：
  - 需要频繁创建和销毁对象。
  - 对象大小相仿。
  - 在堆上分配对象缓慢或者会导致内存碎片。
  - 每个对象都封装了像数据库或者网络连接这样很昂贵又可以重用的资源。

#### 

#### 引申与参考

- 对象池模式与GOF设计模式中享元模式类似。两者都控制了一系列可重用的对象。不同在于重用的含义。
  - 享元对象分享实例间同时拥有的相同部分。享元模式在不同上下文中使用相同对象避免了重复内存使用。
  - 对象池中的对象也被重用了，但是是在不同的时间点上被重用的。重用在对象池中意味着对象在原先的对象用完之后再分配内存。对象池的对象不会在它的生命周期中与其他对象共享数据。
- 将内存中同样类型的对象进行整合，能确保在遍历对象时CPU缓存是满载的。这便是数据局部性模式中介绍的内容。
- 本节内容相关的英文原文：<http://gameprogrammingpatterns.com/object-pool.html>
- 本节内容相关的中文翻译： <http://gpp.tkchu.me/object-pool.html>
