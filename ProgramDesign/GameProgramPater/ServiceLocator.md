## 服务定位模式 Service Locator

提供服务的全局接入点，而不必让用户和实现它的具体类耦合。

### 

### 要点

- 服务定位模式：服务类定义了一堆操作的抽象接口。具体的服务提供者实现这个接口。 分离的服务定位器提供了通过查询合适的提供者，获取服务的方法，同时隐藏了提供者的具体细节和需要定位它的进程。
- 一般通过使用单例或者静态类来实现服务定位模式，提供服务的全局接入点。
- 服务定位模式可以看做是更加灵活，更加可配置的单例模式。如果用得好，它能以很小的运行时开销，换取很大的灵活性。相反，如果用得不好，它会带来单例模式的所有缺点以及更多的运行时开销。
- 使用服务定位器的核心难点是它将依赖，也就是两块代码之间的一点耦合，推迟到运行时再连接。这有了更大的灵活度，但是代价是更难在阅读代码时理解其依赖的是什么。

### 

### 使用场合

- 服务定位模式在很多方面是单例模式的亲兄弟，在应用前应该考虑看看哪个更适合你的需求。
- 让大量内容在程序的各处都能被访问时，就是在制造混乱。对何时使用服务定位模式的最简单的建议就是：尽量少用。
- 与其使用全局机制让某些代码直接接触到它，不妨先考虑将对象传过来。因为这样可以明显地保持解耦，而且可以满足我们大部分的需求。当然，有时候不方便手动传入对象，也可以使用单例的方式。

### 

### 引申与参考

- Unity引擎在它的GetComponent()方法中使用了这个模式，协助组件模式的使用，方便随时获取到指定的组件。
- Microsoft的 XNA框架将这个模式内嵌到它的核心类Game中。每个实例有一个GameServices 对象，能够用来注册和定位任何类型的服务。
- 本节内容相关的英文原文：<http://gameprogrammingpatterns.com/service-locator.html>
- 本节内容相关的中文翻译：<http://gpp.tkchu.me/service-locator.html>
